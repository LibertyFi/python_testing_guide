{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the home page of the project.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Tutorial: A tutorial on how to write tests in Python</li> <li>Rules: The rules for writing Python tests at Libertify</li> </ul>"},{"location":"rules/","title":"Rules","text":"<p>Here are the rules to follow when writing tests:</p>"},{"location":"rules/#project-structure","title":"Project Structure","text":"<ul> <li>Put all test files in the <code>tests</code> directory.</li> <li>The tests directory should have the same internal directory structure as the source code.</li> </ul> <p>For example:</p> <pre><code>project_root/\n\u251c\u2500\u2500 src/\n\u2502 \u251c\u2500\u2500 feature_0/\n\u2502 \u2502 \u251c\u2500\u2500 module_0.py\n\u2502 \u2502 \u2514\u2500\u2500 module_1.py\n\u251c\u2500\u2500 tests/\n\u2502 \u251c\u2500\u2500 feature_0/\n\u2502 \u2502 \u251c\u2500\u2500 test_module_0.py\n\u2502 \u2502 \u2514\u2500\u2500 test_module_1.py\n</code></pre>"},{"location":"rules/#mocking","title":"Mocking","text":"<ul> <li>Use <code>MagicMock</code> and <code>AsyncMock</code>, avoid using <code>Mock</code> unless there\u2019s a good reason not to auto mock the magic methods</li> <li>Use <code>MagicMock(spec_set=MyClass)</code> if only the class attributes need to be mocked</li> <li>Use <code>MagicMock(spec=MyClass)</code> if instance attributes need to be mocked</li> <li>Do not use <code>MagicMock</code> without <code>spec</code> or <code>spec_set</code></li> <li>Use <code>@patch</code> decorators to mock things for a specific test</li> <li>Do not use the <code>patch</code> function as a context manager inside tests</li> <li>Keep in mind that the order of the decorators must match the reverse order of the arguments in the signature of the test function</li> <li>Use <code>spec</code> and <code>spec_set</code> in the patch if it patches a class or an object</li> <li>If the same patch or mock is used by more than 2 tests, define a test fixture</li> </ul> <pre><code>@patch(\"xxx.b\", spec_set=ClassToMock)\n@patch(\"xxx.function\")\ndef test_function(mock_function: MagicMock, mock_b: MagicMock, fixture_mock: MagicMock):\n    ...\n</code></pre>"},{"location":"rules/#file-structure","title":"File Structure","text":"<p>Structure your test file like so:</p> <ol> <li>imports</li> <li>common mock constants</li> <li>test fixtures</li> <li>tests</li> </ol> <p>Use helper functions to avoid duplicating code between tests, for initialization code or mock setup for instance. Put the helper functions inbetween the tests, before the tests that use them.</p> <p>Here's an example:</p> <pre><code>import pytest\n\nfrom src.feature_0.module_0 import MyClass\n\nMOCK_CONSTANT = \"mock_constant\"\n\n@pytest.fixture\ndef my_fixture():\n    ...\n\ndef test_method_0(my_fixture):\n    ...\n    MyClass.method_0()\n    ...\n\ndef helper_function():\n    ...\n\ndef test_method_1(my_fixture):\n    helper_function()\n    ...\n    MyClass.method_1()\n    ...\n\ndef test_method_2(my_fixture):\n    helper_function()\n    ...\n    MyClass.method_2()\n    ...\n</code></pre>"},{"location":"rules/#test-structure","title":"Test Structure","text":"<p>Structure your tests like so:</p> <ol> <li>initialization of variables and mocks</li> <li>call to the function under test</li> <li>mock calls asserts</li> <li>value asserts</li> </ol> <p>Separate each part with an empty line.</p> <p>Here's an example:</p> <pre><code>def test_method_0(fixture_mock: MagicMock):\n    mock_a = MagicMock()\n    mock_b = MagicMock()\n    my_instance = MyClass(mock_a)\n    fixture_mock.return_value = mock_b\n\n    result = my_instance.method_0()\n\n    mock_a.method_0.assert_called_once()\n    mock_b.method_0.assert_called_once()\n\n    assert result == \"expected_value\"\n</code></pre>"},{"location":"tutorial/","title":"Welcome to the Python unit tests tutorial","text":""},{"location":"tutorial/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>pytest installed as a dev dependency</li> <li>pytest-asyncio installed as a dev dependency</li> </ul>"},{"location":"tutorial/#what-unit-tests-are-for","title":"What Unit Tests Are For","text":"<ol> <li>Detecting Bugs Early: Unit tests catch errors and bugs in specific functions or methods before they become larger issues in the overall system.</li> <li>Ensuring Code Quality: They validate that the code behaves as intended, improving reliability.</li> <li>Facilitating Refactoring: With a suite of unit tests, you can confidently make changes to your codebase knowing that tests will alert you if something breaks.</li> <li>Documenting Behavior: Tests serve as documentation by illustrating how functions or methods are intended to work.</li> <li>Improving Development Speed: Though writing tests may seem like extra work, they save time in the long run by reducing debugging time and ensuring stability.</li> </ol>"},{"location":"tutorial/#how-to-write-unit-tests","title":"How to Write Unit Tests","text":""},{"location":"tutorial/#the-basics","title":"The Basics","text":""},{"location":"tutorial/#project-structure","title":"Project structure","text":"<p>The test files should be located in the <code>tests</code> directory. Then, for each source file/module, there should be a corresponding test file. The tests directory should have the same directory structure as the source code.</p> <p>For example, if we have the following project structure:</p> <pre><code>src/\n\u251c\u2500\u2500 level_0/\n\u2502 \u251c\u2500\u2500 calculator.py\n</code></pre> <p>The test files should be located in the <code>tests</code> directory.</p> <pre><code>tests/\n\u251c\u2500\u2500 level_0/\n\u2502 \u251c\u2500\u2500 test_calculator.py\n</code></pre>"},{"location":"tutorial/#how-big-should-each-unit-test-be","title":"How big should each unit test be?","text":"<p>The goal of unit testing is to verify that small, isolated units of code (usually functions or methods) perform correctly and handle edge cases as designed.</p> <p>As such a unit test should be as simple as possible and test only one thing.</p> <p>Take the following example of a calculator module:</p> calculator.py<pre><code>def add(a: float, b: float) -&gt; float:\n    return a + b\n\n\ndef subtract(a: float, b: float) -&gt; float:\n    return a - b\n\n\ndef multiply(a: float, b: float) -&gt; float:\n    return a * b\n\n\ndef divide(a: float, b: float) -&gt; float:\n    if b == 0:\n        msg = \"Cannot divide by zero\"\n        raise ValueError(msg)\n    return a / b\n</code></pre> <p>We could test that module with a single test, like so:</p> test_calculator.py<pre><code>def test_operations() -&gt; None:\n    assert add(2, 3) == 5\n    assert add(-1, 1) == 0\n\n    assert subtract(5, 2) == 3\n    assert subtract(0, 1) == -1\n\n    assert multiply(2, 3) == 6\n    assert multiply(0, 5) == 0\n\n    assert divide(6, 2) == 3\n    with pytest.raises(ValueError, match=\"divide by zero\"):\n        divide(6, 0)\n</code></pre> <p>But that test is testing way too many different things. If it breaks, all we know is that the calculator doesn\u2019t work any more, we don\u2019t know which parts still work and which part broke.</p> <p>Whereas if we split it into true unit tests, like so:</p> test_calculator.py<pre><code>def test_add() -&gt; None:\n    assert add(2, 3) == 5\n    assert add(-1, 1) == 0\n\n\ndef test_subtract() -&gt; None:\n    assert subtract(5, 2) == 3\n    assert subtract(0, 1) == -1\n\n\ndef test_multiply() -&gt; None:\n    assert multiply(2, 3) == 6\n    assert multiply(0, 5) == 0\n\n\ndef test_divide_valid() -&gt; None:\n    assert divide(6, 2) == 3\n    assert divide(-6, 2) == -3\n\n\ndef test_divide_by_zero() -&gt; None:\n    with pytest.raises(ValueError, match=\"divide by zero\"):\n        divide(6, 0)\n</code></pre> <p>If one test breaks, we instantly know which part of the calculator is broken. We even have a specific test for the edge case of the division operation.</p>"},{"location":"tutorial/#mocking","title":"Mocking","text":""},{"location":"tutorial/#what-is-mocking","title":"What is mocking?","text":"<p>Mocking is a technique used to replace a function or method with a mock implementation in order to test the code that uses it.</p> <p>Take the following example of a simple class:</p> session.py<pre><code>from src.level_1.interface import connect_to_server\n\n\nclass Session:\n    def connect(self) -&gt; bool:\n        return connect_to_server()\n</code></pre> <p>We could test the single method of the class like so:</p> test_session.py<pre><code>def test_connect() -&gt; None:\n    session = Session()\n\n    result = session.connect()\n\n    assert result\n</code></pre> <p>But the <code>connect_to_server</code> function comes from an external module, which we don't control in the <code>session</code> module. Each unit test should only test one unit of code. This test is actually testing both <code>session.connect</code> and <code>interface.connect_to_server</code>. If the test fails, there is no way to tell if it's because of the <code>connect</code> method or the <code>connect_to_server</code> function.</p>"},{"location":"tutorial/#mocking-a-function","title":"Mocking a function","text":"<p>To properly test the above <code>connect</code> method, we should mock the <code>connect_to_server</code> function. Here's how we can do it, using the <code>patch</code> function (here in decorator form):</p> test_session.py<pre><code>@patch(\"src.level_1.session.connect_to_server\")\ndef test_connect_success(mock_connect_to_server: MagicMock) -&gt; None:\n    session = Session()\n    mock_connect_to_server.return_value = True\n\n    connected = session.connect()\n\n    # Check that the mock was called by the connect method\n    mock_connect_to_server.assert_called_once()\n\n    # Check that the connect method returns the correct value\n    assert connected\n\n\n@patch(\"src.level_1.session.connect_to_server\")\ndef test_connect_failure(mock_connect_to_server: MagicMock) -&gt; None:\n    session = Session()\n    mock_connect_to_server.return_value = False\n\n    connected = session.connect()\n\n    mock_connect_to_server.assert_called_once()\n\n    assert not connected\n</code></pre> <p>Mocking the <code>connect_to_server</code> function has several benefits:</p> <ul> <li>we're only testing the <code>connect</code> method, regardless of the actual implementation of <code>connect_to_server</code></li> <li>we're able to have two test cases for the <code>connect</code> method, one for when the connection is successful and one for when it's not because we control the return value of the mock</li> <li>we're not executing the actual <code>connect_to_server</code> function, which could require a specific setup, make network requests, or even be an expensive operation</li> </ul> <p>Patch in the right place</p> <p>When using the patch function, it's important to patch the function where it's used, not where it's defined.</p> <p> <code>patch(\"src.level_1.session.connect_to_server\")</code></p> <p> <code>patch(\"src.level_1.interface.connect_to_server\")</code></p>"},{"location":"tutorial/#mocking-an-object","title":"Mocking an object","text":"<p>Let's use the following class as an example:</p> session.py<pre><code>from src.level_2.interface import ServerInterface\n\n\nclass Session:\n    interface: ServerInterface\n\n    def __init__(self, interface: ServerInterface) -&gt; None:\n        self.interface = interface\n\n    def connect(self) -&gt; bool:\n        return self.interface.connect_to_server()\n</code></pre> <p>In order to test the <code>connect</code> method, we first need to instantiate a <code>Session</code> object, which requires an <code>ServerInterface</code> object.</p> <p>Since we don't know what creating an actual <code>ServerInterface</code> object entails, and we don't want to test the <code>ServerInterface</code> class, we need to mock the <code>ServerInterface</code> object.</p>"},{"location":"tutorial/#simple-mock","title":"Simple Mock","text":"<p>The simplest way to mock an object is to use the <code>Mock</code> class, from the <code>unittest.mock</code> module.</p> test_session.py<pre><code>def test_connect_success() -&gt; None:\n    interface = Mock()\n    interface.connect_to_server.return_value = True\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>Here we create a <code>Mock</code> object and assign a return value to its <code>connect_to_server</code> attribute.</p> <p>Now when the test calls <code>session.connect()</code>, it will call the <code>connect_to_server</code> method of the <code>Mock</code> instead of an actual <code>ServerInterface</code> object.</p> <p>And since we control the mock, we can even check that the <code>connect_to_server</code> method is indeed called by the <code>connect</code> method.</p>"},{"location":"tutorial/#specifying-the-mocks-structure","title":"Specifying the Mock's Structure","text":"<p><code>Mock</code> generates attributes on the fly so that the mock can be used automatically without worrying about setting it up. The downside of this is that you can use attributes that don't even exist on the original object.</p> <p>Here's an example:</p> interface.py<pre><code>import logging\n\n\nclass ServerInterface:\n    class_attribute = \"This is a class attribute\"\n\n    def __init__(self) -&gt; None:\n        self.instance_attribute = \"This is an instance attribute\"\n\n    def connect_to_server(self) -&gt; bool:\n        logging.info(\"Called actual connect_to_server\")\n        return True\n</code></pre> test_session.py<pre><code>def test_connect_success_shouldnt_be_allowed() -&gt; None:\n    interface = Mock()\n    interface.connect_to_server.return_value = True\n    # This doesn't raise an error, but it shouldn't be possible\n    interface.not_an_actual_attribute = \"This shouldn't be possible\"\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>The <code>ServerInterface</code> object we want to mock doesn't have a <code>not_an_actual_attribute</code> attribute, so we shouldn't allow the mock to have it. Moreover, even if the <code>connect</code> method actually uses <code>not_an_actual_attribute</code>, this test will still pass even though the attribute doesn't actually exist, which will make <code>connect</code> crash at runtime.</p> <p>Thankfully, there are ways to specify the structure of the mock object.</p> <p>The best (strictest) way is to use the <code>spec_set</code> argument to specify to the <code>Mock</code> constructor the class of the object we want to mock:</p> test_session.py<pre><code>def test_connect_success_spec_set() -&gt; None:\n    interface = Mock(spec_set=ServerInterface)\n    interface.connect_to_server.return_value = True\n    # This raises an AttributeError\n    # interface.not_an_actual_attribute = \"This shouldn't be possible\"  # noqa: ERA001\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>This will raise an error if we try to access an attribute that doesn't exist in the <code>ServerInterface</code> class.</p> <p>Unfortunately, instance attributes are not part of the class specification, so they don't exist as far as <code>spec_set</code> is concerned.</p> test_session.py<pre><code>def test_connect_success_spec_set_instance_attribute() -&gt; None:\n    interface = Mock(spec_set=ServerInterface)\n    interface.connect_to_server.return_value = True\n    # This works as expected\n    interface.class_attribute = \"This is a class attribute\"\n    # This raises an AttributeError\n    # interface.instance_attribute = \"This attribute doesn't exist when the mock is created\"  # noqa: ERA001\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>If you need to mock an instance attribute (or any attribute that is defined at runtime), you can use <code>spec</code> instead of <code>spec_set</code>:</p> test_session.py<pre><code>def test_connect_success_simple_spec_for_instance_attribute() -&gt; None:\n    interface = Mock(spec=ServerInterface)\n    interface.connect_to_server.return_value = True\n    interface.class_attribute = \"This is a class attribute\"\n    # Now this works\n    interface.instance_attribute = \"This is an instance attribute\"\n    # But this will still raise an AttributeError\n    # logging.info(f\"{interface.unset_instance_attribute}\")  # noqa: ERA001\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p><code>spec</code> vs <code>spec_set</code></p> <p><code>spec</code> is not as strict as <code>spec_set</code>, it will simply ensure that an attribute can't be accessed if it has not been set, whether by the test or the specified class:</p> test_session.py<pre><code>def test_connect_success_simple_spec_is_lax() -&gt; None:\n    interface = Mock(spec=ServerInterface)\n    interface.connect_to_server.return_value = True\n    # This will not raise an error\n    interface.not_an_actual_attribute = \"This doesn't exist in the specified class\"\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>One-liner syntax</p> <p>You can also define the mock and its attributes at the same time if you prefer the one-liner syntax.</p> test_session.py<pre><code>def test_connect_success_simple_spec_one_liner() -&gt; None:\n    interface = Mock(\n        spec=ServerInterface,\n        class_attribute=\"This is a class attribute\",\n        instance_attribute=\"This is an instance attribute\",\n        connect_to_server=Mock(return_value=True),\n    )\n</code></pre>"},{"location":"tutorial/#when-mock-is-not-enough","title":"When Mock is not enough","text":"<p>Sometimes using <code>Mock</code> is not enough. Let's take this new example class:</p> session.py<pre><code>from src.level_3.interface import ServerInterface\n\n\nclass Session:\n    interface: ServerInterface\n    active_connections: int = 0\n\n    def __init__(self, interface: ServerInterface) -&gt; None:\n        self.interface = interface\n\n    def connect(self) -&gt; bool:\n        self.active_connections += 1\n        return self.interface.connect_to_server()\n\n    async def aconnect(self) -&gt; bool:\n        self.active_connections += 1\n        return await self.interface.aconnect_to_server()\n</code></pre>"},{"location":"tutorial/#magicmock","title":"MagicMock","text":"<p>We can try testing the <code>connect</code> method with <code>Mock</code> as we did before:</p> test_session.py<pre><code>def test_connect_success_missing_magic_method() -&gt; None:\n    interface = Mock(spec_set=ServerInterface)\n    session = Session(interface)\n    # This raises a TypeError because Mock doesn't implement the magic/special __add__ method so it can't effectively\n    # mock an int\n    # session.active_connections = Mock()  # noqa: ERA001\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>Unfortunately mocking the <code>active_connections</code> attribute with <code>Mock</code> doesn't work because <code>Mock</code> doesn't implement the magic/special <code>__add__</code> method so it can't effectively mock an <code>int</code>.</p> <p>We could mock the <code>__add__</code> method ourselves, but that would be tedious and error-prone since it's not always obvious which magic methods are used by the code.</p> <p>Fortunately, <code>Mock</code> has a subclass called <code>MagicMock</code> that automatically implements the magic/special methods:</p> test_session.py<pre><code>def test_connect_success_magic() -&gt; None:\n    interface = Mock(spec_set=ServerInterface)\n    session = Session(interface)\n    # This works as expected because MagicMock automatically implements the magic/special methods, including __add__\n    session.active_connections = MagicMock()\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>Using <code>MagicMock</code> we don't have to worry about mocking any magic/special methods ourselves.</p> <p>Magic Methods</p> <p>If you use the <code>spec</code> or <code>spec_set</code> arguments then only magic methods that exist in the spec will be created. You can override the magic methods of a <code>MagicMock</code> by setting them just like you would with a normal <code>Mock</code>.</p>"},{"location":"tutorial/#asyncmock","title":"AsyncMock","text":"<p>We'd also like to test the <code>aconnect</code> method, but it's an async function so we can't use a simple <code>Mock</code> to mock it.</p> <p>Fortunately, <code>Mock</code> has a subclass called <code>AsyncMock</code> that can be used to mock async functions:</p> test_session.py<pre><code>@pytest.mark.asyncio\nasync def test_aconnect_async_mock() -&gt; None:\n    interface = Mock(spec_set=ServerInterface)\n    # This raises a TypeError because the mock will simply return a boolean instead of a coroutine\n    # interface.aconnect_to_server.return_value = True  # noqa: ERA001\n    # We need to use AsyncMock to mock the async function properly\n    interface.aconnect_to_server = AsyncMock(return_value=True)\n    session = Session(interface)\n\n    connected = await session.aconnect()\n\n    # We could use assert_called_once() as well, but assert_awaited_once() is more specific\n    interface.aconnect_to_server.assert_awaited_once()\n\n    assert connected\n</code></pre> <p>AsyncMock calls</p> <p>You can use <code>assert_awaited_once()</code> or similar methods to check that an async function is awaited and not just called.</p> <p>Decorator for async tests</p> <p>The <code>@pytest.mark.asyncio</code> decorator is required on each async test.</p>"},{"location":"tutorial/#mocking-a-class","title":"Mocking a class","text":"<p>Sometimes we need to mock a class and not just an object or a function.</p> <p>Let's take the following example:</p> session.py<pre><code>from src.level_4.database import Database as Db\nfrom src.level_4.interface import ServerInterface\n\n\nclass Session:\n    interface: ServerInterface\n\n    def __init__(self) -&gt; None:\n        self.interface = ServerInterface()\n\n    def connect(self) -&gt; bool:\n        with Db.get() as conn:\n            conn.begin()\n            # TODO: write some data to the database\n            conn.commit()\n\n        return self.interface.connect_to_server()\n</code></pre> <p>Instead of passing the interface as an argument when creating the <code>Session</code> object, it is instantiated by the class itself at initialization.</p> <p>So we need to mock the full class, not just an instance of it.</p> test_session.py<pre><code>@patch(\"src.level_4.session.ServerInterface\")\ndef test_connect_success(mock_interface_class: MagicMock) -&gt; None:\n    mock_interface = Mock(spec_set=ServerInterface)\n    mock_interface.connect_to_server.return_value = True\n    mock_interface_class.return_value = mock_interface\n    session = Session()\n\n    connected = session.connect()\n\n    mock_interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>We use the <code>@patch</code> decorator to mock the <code>ServerInterface</code> class, then we create a <code>Mock</code> object and assign it to the <code>return_value</code> of the mock class.</p> <p>Patch in the right place</p> <p>When using the patch function, it's important to patch the function where it's used, not where it's defined.</p> <p> <code>patch(\"src.level_4.session.ServerInterface\")</code></p> <p> <code>patch(\"src.level_4.interface.ServerInterface\")</code></p> <p>The test works fine, but we forgot to mock the <code>Database</code> class so the test is actually using the real Database, which could be dangerous!</p> <p>So let's mock the <code>Database</code> class as well:</p> test_session.py<pre><code>@patch(\"src.level_4.session.ServerInterface\")\n@patch(\"src.level_4.session.Db\", spec_set=Database)\ndef test_connect_success_mock_db(mock_db: MagicMock, mock_interface_class: MagicMock) -&gt; None:\n    mock_interface = Mock(spec_set=ServerInterface)\n    mock_interface.connect_to_server.return_value = True\n    mock_interface_class.return_value = mock_interface\n    mock_conn = MagicMock(spec_set=Connection)\n    mock_db.get.return_value.__enter__.return_value = mock_conn\n    session = Session()\n\n    connected = session.connect()\n\n    mock_conn.begin.assert_called_once()\n    mock_conn.commit.assert_called_once()\n    mock_interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>Since the <code>Database</code> class is used with a context manager, using <code>with</code>, through its <code>get</code> method, the mock definition is a bit more complicated.</p> <p>Using <code>spec_set</code> or <code>spec</code> inside the patch decorator</p> <p>Use <code>spec_set</code> or <code>spec</code> inside a patch decorator to specify the structure of the resulting mock.</p> <p>The order of patch decorators matters</p> <p>The patch decorators automatically provide the test function with the mocks as arguments. The arguments are provided in the same order as the decorators are applied to the function, which is the opposite order as the decorators appear above the test function. Thus the first argument will match the decorator closest to the function and the last argument the furthest.</p> <pre><code>@patch(\"xxx.b\")\n@patch(\"xxx.a\")\ndef test_function(mock_a, mock_b):\n    ...\n</code></pre>"},{"location":"tutorial/#test-fixtures","title":"Test Fixtures","text":"<p>Let's use a new example class:</p> session.py<pre><code>from src.level_5.database import Database as Db\nfrom src.level_5.interface import ConnectionCounter, ServerInterface\n\n\nclass Session:\n    interface: ServerInterface\n\n    def __init__(self, connection_counter: ConnectionCounter) -&gt; None:\n        self.interface = ServerInterface()\n        self.connection_counter = connection_counter\n\n    def connect(self) -&gt; bool:\n        with Db.get() as conn:\n            conn.begin()\n            # TODO: write some data to the database\n            conn.commit()\n        connected = self.interface.connect_to_server()\n        if connected:\n            self.connection_counter.increment()\n        return connected\n</code></pre>"},{"location":"tutorial/#what-are-test-fixtures","title":"What are test fixtures?","text":"<p>In our example, any test of the <code>Session</code> class's <code>connect</code> method will need to mock the <code>ServerInterface</code> and <code>Database</code> classes as well as a <code>ConnectionCounter</code> object. Duplicating the mock setup code would be a bad practice.</p> <p>A test fixture allows us to create a test setup that is used by several tests.</p> <p>It can create a mock and provide it to the tests:</p> test_session.py<pre><code>@pytest.fixture\ndef mock_connection_counter() -&gt; Mock:\n    return Mock(spec_set=ConnectionCounter)\n</code></pre> <p>It can also patch a class and provide the resulting mock to the tests:</p> test_session.py<pre><code>@pytest.fixture\ndef mock_interface_class() -&gt; Generator[MagicMock, None, None]:\n    with patch(\"src.level_5.session.ServerInterface\", spec_set=ServerInterface) as mock:\n        yield mock\n</code></pre> <p>Patch decorator or context manager</p> <p>As we've already seen, the <code>patch</code> function can be used as a decorator, which applies the patch to the scope of the test function. It can also be used as a context manager, in which case the patch is applied to the scope of the with block.</p> <p>A test fixture can also return more complicated objects:</p> test_session.py<pre><code>@pytest.fixture(autouse=True)\ndef mock_db_connection() -&gt; Generator[tuple[MagicMock, MagicMock], None, None]:\n    with patch(\"src.level_5.session.Db\", spec=Database) as mock_db:\n        mock_conn = MagicMock(spec_set=Connection)\n        mock_db.get.return_value.__enter__.return_value = mock_conn\n        yield mock_db, mock_conn\n</code></pre>"},{"location":"tutorial/#how-to-use-test-fixtures","title":"How to use test fixtures","text":"<p>To use a test fixture, we just add it as an argument to the test function.</p> test_session.py<pre><code>def test_connect_success(mock_interface_class: MagicMock, mock_connection_counter: Mock) -&gt; None:\n    mock_interface = Mock(spec_set=ServerInterface)\n    mock_interface.connect_to_server.return_value = True\n    mock_interface_class.return_value = mock_interface\n    session = Session(mock_connection_counter)\n\n    connected = session.connect()\n\n    mock_interface.connect_to_server.assert_called_once()\n    mock_connection_counter.increment.assert_called_once()\n\n    assert connected\n</code></pre> <p>The fixture code will be executed automatically before the test function is executed.</p> <p>To use it in another test, we just pass it as an argument to that function as well and it will be executed again.</p> test_session.py<pre><code>def test_connect_failure(mock_interface_class: MagicMock, mock_connection_counter: Mock) -&gt; None:\n    mock_interface = Mock(spec_set=ServerInterface)\n    mock_interface.connect_to_server.return_value = False\n    mock_interface_class.return_value = mock_interface\n    session = Session(mock_connection_counter)\n\n    connected = session.connect()\n\n    mock_interface.connect_to_server.assert_called_once()\n    mock_connection_counter.increment.assert_not_called()\n\n    assert not connected\n</code></pre> <p>We've successfully avoided duplicating the mock setup code.</p> <p>But what about the <code>Database</code> class? We haven't added it as an argument to our test functions. So is the actual Database called by our tests? No! The <code>mock_db_connection</code> fixture was declared with the <code>autouse</code> flag, which means that it will be used automatically by all tests, without needing to pass it as an argument to the test function.</p> <p>Seeing logs when running the tests</p> <p>By default when you run the tests using <code>pytest</code>, the logs from your code are not displayed. If you want to see them, you can run the tests with <code>-v --log-cli-level=INFO</code>. In our example, if you activate the logs, you'll see that the logs from the actual <code>Database</code> class only show up if the <code>autouse</code> flag is not set.</p> database.py<pre><code>class Connection:\n    def begin(self) -&gt; None:\n        logging.info(\"Called actual begin\")\n\n    def commit(self) -&gt; None:\n        logging.info(\"Called actual commit\")\n</code></pre> <p>But what if we want to check that the code under test actually calls the database? Since the <code>mock_db_connection</code> fixture is automatically used by all tests, we don't have a reference to the mock on which to call <code>assert_called_once()</code> or similar methods.</p> <p>Fortunately, we can pass the <code>mock_db_connection</code> fixture as an explicit argument to the test function and then reference it in the test.</p> test_session.py<pre><code>def test_connect_success_mock_db(\n    mock_interface_class: MagicMock, mock_connection_counter: Mock, mock_db_connection: tuple[MagicMock, MagicMock]\n) -&gt; None:\n    _, mock_conn = mock_db_connection\n    mock_interface = Mock(spec_set=ServerInterface)\n    mock_interface.connect_to_server.return_value = True\n    mock_interface_class.return_value = mock_interface\n    session = Session(mock_connection_counter)\n\n    connected = session.connect()\n\n    mock_conn.begin.assert_called_once()\n    mock_conn.commit.assert_called_once()\n    mock_interface.connect_to_server.assert_called_once()\n    mock_connection_counter.increment.assert_called_once()\n\n    assert connected\n</code></pre> <p>Combining fixtures and patch decorators</p> <p>The patch decorators automatically provide the test function with the mocks as arguments. The arguments are provided in the same order as the decorators are applied to the function, which is the opposite order as the decorators appear above the test function. The arguments for the test fixtures must come after the arguments for the patch decorators: <pre><code>@patch(\"xxx.b\")\n@patch(\"xxx.a\")\ndef test_function(mock_a, mock_b, fixture_mock):\n    ...\n</code></pre></p>"},{"location":"tutorial/#advanced-mocking","title":"Advanced Mocking","text":""},{"location":"tutorial/#side-effects","title":"Side Effects","text":"<p>We've already seen that we can specify the return value of a mock. But what if that's not enough?</p> <p>Let's take the following example:</p> session.py<pre><code>import time\n\nfrom src.level_6.interface import ServerInterface\n\n\nclass Session:\n    interface: ServerInterface\n    connected: bool\n\n    def __init__(self) -&gt; None:\n        self.interface = ServerInterface()\n        self.connected = False\n\n    def connect(self) -&gt; None:\n        self.connected = self.interface.connect_to_server()\n\n    def start(self) -&gt; None:\n        self.connect()\n        if not self.connected:\n            return\n        while self.interface.is_server_connected():\n            time.sleep(1)\n</code></pre> <p>We want to test the <code>start</code> method. It uses the <code>connect</code> method and the <code>is_server_connected</code> method so if we want to implement a proper unit test, we need to mock both, otherwise we're actually testing all three methods at the same time.</p> <p>First of all, we can define a fixture for the <code>ServerInterface</code> class:</p> test_session.py<pre><code>@pytest.fixture\ndef mock_interface_class() -&gt; Generator[MagicMock, None, None]:\n    with patch(\"src.level_6.session.ServerInterface\", spec_set=ServerInterface) as mock:\n        yield mock\n</code></pre> <p>Second, we don't want our test to actually sleep for multiple seconds, we just want to check that it calls the <code>sleep</code> function, so let's define a fixture for the <code>time.sleep</code> function:</p> test_session.py<pre><code>@pytest.fixture\ndef mock_sleep() -&gt; Generator[MagicMock, None, None]:\n    with patch(\"src.level_6.session.time.sleep\") as mock:\n        yield mock\n</code></pre> <p>Patch in the right place</p> <p>Remember: when using the patch function, it's important to patch the function where it's used, not where it's defined.</p> <p> <code>patch(\"src.level_6.session.time.sleep\")</code></p> <p> <code>patch(\"time.sleep\")</code></p> <p>But there are two problems that we've not encountered yet:</p> <ul> <li>the behavior of the <code>start</code> method depends on what the <code>connect</code> method does, and not what it returns. How can we mock the behavior of a method and not just its return value?</li> <li><code>is_server_connected</code> is called multiple times and the behavior of the <code>start</code> method depends on the value returned by this method each time it's called. How can we set multiple successive return values for a mock?</li> </ul> <p>That's where the <code>side_effect</code> attribute comes in.</p> test_session.py<pre><code>def test_start_success(mock_sleep: MagicMock, mock_interface_class: MagicMock) -&gt; None:\n    mock_interface = Mock(spec_set=ServerInterface)\n    mock_interface.is_server_connected.side_effect = [True, True, False]\n    mock_interface_class.return_value = mock_interface\n    mock_sleep.return_value = None\n    session = Session()\n\n    def connect() -&gt; None:\n        session.connected = True\n\n    session.connect = MagicMock(side_effect=connect)\n\n    session.start()\n\n    session.connect.assert_called_once()\n    assert mock_interface.is_server_connected.call_count == 3\n</code></pre> <p>The <code>side_effect</code> attribute can serve multiple purposes:</p> <ul> <li>if set to a specific value, the mock will return that value every time its called, it's equivalent to setting the <code>return_value</code> attribute</li> <li>if set to an iterable, the mock will return successive values from the iterable each time its called</li> <li>if set to a function, the mock will call the function every time its called</li> </ul> <p>Here we used the iterable and function cases.</p> <p>If we don't specify the <code>side_effect</code>, the mock will not do anything, and that's a valid test case too!</p> test_session.py<pre><code>def test_start_not_connected(mock_sleep: MagicMock, mock_interface_class: MagicMock) -&gt; None:\n    mock_interface = Mock(spec_set=ServerInterface)\n    mock_interface_class.return_value = mock_interface\n    mock_sleep.return_value = None\n    session = Session()\n    session.connect = MagicMock()\n\n    session.start()\n\n    session.connect.assert_called_once()\n    mock_interface.is_server_connected.assert_not_called()\n</code></pre> <p>Mocking methods</p> <p>It can be seen as overkill to mock the other methods of a given class when testing a single method even though each methods will have its own unit tests anyway. But by doing it this way, we're making sure that breaking one method will only break the tests of that specific method and not the tests of all methods which call it.</p>"},{"location":"tutorial/#checking-mock-calls","title":"Checking Mock Calls","text":"<p>We've already seen that we can check if a mock has been called or not. But we can also check the details of the calls to the mock.</p> <p>Let's take the following example:</p> session.py<pre><code>from src.level_7.interface import ServerInterface\n\n\nclass Session:\n    interface: ServerInterface\n\n    def __init__(self, interface: ServerInterface) -&gt; None:\n        self.interface = interface\n\n    def send_messages(self, messages: list[str]) -&gt; None:\n        for message in messages:\n            self.interface.send_message(message)\n</code></pre> <p>We want to test the <code>send_messages</code> method.</p> <p>Let's test what happens when the method is called with a single message:</p> test_session.py<pre><code>def test_send_messages_one_message(mock_interface: MagicMock) -&gt; None:\n    session = Session(mock_interface)\n\n    session.send_messages([\"Hello, World\"])\n\n    mock_interface.send_message.assert_called_once_with(\"Hello, World\")\n</code></pre> <p>We check that the mock was called with the correct argument using <code>assert_called_once_with</code>.</p> <p>Let's add a test for a call with multiple messages:</p> test_session.py<pre><code>def test_send_messages_multiple_messages(mock_interface: MagicMock) -&gt; None:\n    session = Session(mock_interface)\n\n    session.send_messages([\"Hello, World\", \"Hello, Universe\"])\n\n    # We can check the number of calls to the mock\n    assert mock_interface.send_message.call_count == 2\n    # We can check the order and content of the calls to the mock\n    # You can set the \"any_order\" flag to True if you don't want to check the order of the calls, the default is False\n    mock_interface.send_message.assert_has_calls(\n        [\n            call(\"Hello, World\"),\n            call(\"Hello, Universe\"),\n        ]\n    )\n</code></pre> <p>We check the number of calls to the mock, as well as the order and content of the calls.</p> <p>Order of mock calls</p> <p>You can set the <code>any_order</code> flag of <code>assert_has_calls</code> to <code>True</code> if the order of the calls shouldn't matter.</p>"},{"location":"tutorial/#exceptions","title":"Exceptions","text":"<p>There are two cases where we need to handle exceptions in our tests:</p> <ul> <li>the code is supposed to catch an exception</li> <li>the code is supposed to raise an exception</li> </ul> <p>Let's take the following example:</p> session.py<pre><code>from src.level_8.interface import ServerInterface\n\n\nclass SessionError(Exception):\n    pass\n\n\nclass Session:\n    interface: ServerInterface\n    connected: bool\n\n    def __init__(self) -&gt; None:\n        self.interface = ServerInterface()\n        self.connected = False\n        self.ignore_connection_errors = False\n\n    def connect(self) -&gt; None:\n        try:\n            self.connected = self.interface.connect_to_server()\n        except ConnectionError:\n            self.connected = False\n        if not self.connected and not self.ignore_connection_errors:\n            msg = \"Failed to connect to server\"\n            raise SessionError(msg)\n</code></pre> <p>As before, we start by defining a fixture for the <code>ServerInterface</code> class:</p> test_session.py<pre><code>@pytest.fixture\ndef mock_interface_class() -&gt; Generator[MagicMock, None, None]:\n    with patch(\"src.level_8.session.ServerInterface\", spec_set=ServerInterface) as mock:\n        yield mock\n</code></pre>"},{"location":"tutorial/#check-that-an-exception-is-caught","title":"Check that an exception is caught","text":"<p>Let's test that the <code>connect</code> method catches the <code>ConnectionError</code> exception raised by the <code>interface.connect_to_server</code> method:</p> test_session.py<pre><code>def test_connect_interface_exception(mock_interface_class: MagicMock) -&gt; None:\n    mock_interface = Mock(spec_set=ServerInterface)\n    mock_interface.connect_to_server.side_effect = ConnectionError(\"Failed to connect to server\")\n    mock_interface_class.return_value = mock_interface\n    session = Session()\n    session.ignore_connection_errors = True\n\n    session.connect()\n\n    mock_interface.connect_to_server.assert_called_once()\n\n    assert not session.connected\n</code></pre> <p>This is another purpose of the <code>side_effect</code> attribute: if provided with an exception class or instance, the mock will raise that exception instead of returning a value.</p> <p>Clearing a side effect</p> <p>A <code>side_effect</code> can be cleared by setting it to None</p>"},{"location":"tutorial/#check-that-an-exception-is-raised","title":"Check that an exception is raised","text":"<p>Let's test that the <code>connect</code> method raises the <code>SessionError</code> exception when expected:</p> test_session.py<pre><code>def test_connect_session_exception(mock_interface_class: MagicMock) -&gt; None:\n    mock_interface = Mock(spec_set=ServerInterface)\n    mock_interface.connect_to_server.return_value = False\n    mock_interface_class.return_value = mock_interface\n    session = Session()\n\n    # The match argument allows us to check that the exception message matches a specific regex pattern.\n    with pytest.raises(SessionError, match=\"Failed to connect to server\"):\n        session.connect()\n\n    mock_interface.connect_to_server.assert_called_once()\n</code></pre> <p>Since the code under test raises an exception, we need the test to catch it or it will crash. We also want to check that the exception was raised, that it's the correct exception type and that it's the correct message. <code>pytest.raises</code> allows us to do all of this.</p> <p>Match of pytest.raises</p> <p>The match argument allows us to check that the exception message matches a specific regex pattern, not just a static string.</p>"}]}