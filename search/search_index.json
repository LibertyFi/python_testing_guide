{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the home page of the project.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Tutorial: A tutorial on how to write tests in Python</li> <li>Guide: The guidelines for writing Python tests at Libertify</li> </ul>"},{"location":"guide/","title":"Guide","text":"<ul> <li>Use MagicMock and AsyncMock, avoid using Mock unless there\u2019s a good reason not to auto mock the magic methods</li> <li>Use MagicMock with spec_set if only the class attributes need to be mocked MagicMock(spec_set=MyClass)</li> <li>Use MagicMock with spec if instance attributes need to be mocked. You can specify the instance attributes in a one liner MagicMock(spec=MyClass, attribute_0 = \u201cvalue0\u201d, attribute_1 = \u201cvalue1\u201d).</li> <li>Never use MagicMock without spec or spec_set</li> <li>Structure your test file like so:</li> <li>imports</li> <li>common mock constants</li> <li>test fixtures</li> <li>tests</li> <li>Use helper functions to avoid duplicating code between tests, for initialization code or mock setup for instance. Put the helper functions inbetween the tests, before the tests that use them.</li> <li>Use patch decorators to mock things for a specific test</li> <li>Use spec and spec_set in the patch if it patches a class or an object</li> <li>If the same patch or variable mock is used by more than 2 tests, make it a test fixture</li> <li>Structure your tests like so:</li> <li>initialization of variables and mocks</li> <li>empty line</li> <li>call to the function under test</li> <li>empty line</li> <li>mock calls asserts</li> <li>empty line</li> <li>value asserts</li> </ul>"},{"location":"tutorial/","title":"Welcome to the Python unit tests tutorial","text":""},{"location":"tutorial/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>pytest installed as a dev dependency</li> </ul>"},{"location":"tutorial/#what-unit-tests-are-for","title":"What Unit Tests Are For","text":"<ol> <li>Detecting Bugs Early: Unit tests catch errors and bugs in specific functions or methods before they become larger issues in the overall system.</li> <li>Ensuring Code Quality: They validate that the code behaves as intended, improving reliability.</li> <li>Facilitating Refactoring: With a suite of unit tests, you can confidently make changes to your codebase knowing that tests will alert you if something breaks.</li> <li>Documenting Behavior: Tests serve as documentation by illustrating how functions or methods are intended to work.</li> <li>Improving Development Speed: Though writing tests may seem like extra work, they save time in the long run by reducing debugging time and ensuring stability.</li> </ol>"},{"location":"tutorial/#how-to-write-unit-tests","title":"How to Write Unit Tests","text":""},{"location":"tutorial/#the-basics","title":"The Basics","text":""},{"location":"tutorial/#project-structure","title":"Project structure","text":"<p>The test files should be located in the <code>tests</code> directory. Then, for each source file/module, there should be a corresponding test file. The tests directory should have the same directory structure as the source code.</p> <p>For example, if we have the following project structure:</p> <pre><code>src/\n\u251c\u2500\u2500 level_0/\n\u2502 \u251c\u2500\u2500 calculator.py\n</code></pre> <p>The test files should be located in the <code>tests</code> directory.</p> <pre><code>tests/\n\u251c\u2500\u2500 level_0/\n\u2502 \u251c\u2500\u2500 test_calculator.py\n</code></pre>"},{"location":"tutorial/#what-should-a-unit-test-do","title":"What should a unit test do?","text":"<p>The goal of unit testing is to verify that small, isolated units of code (usually functions or methods) perform correctly and handle edge cases as designed.</p> <p>As such a unit test should be as simple as possible and test only one thing.</p> <p>Take the following example of a calculator module:</p> calculator.py<pre><code>def add(a: float, b: float) -&gt; float:\n    return a + b\n\n\ndef subtract(a: float, b: float) -&gt; float:\n    return a - b\n\n\ndef multiply(a: float, b: float) -&gt; float:\n    return a * b\n\n\ndef divide(a: float, b: float) -&gt; float:\n    if b == 0:\n        msg = \"Cannot divide by zero\"\n        raise ValueError(msg)\n    return a / b\n</code></pre> <p>We could test that module with a single test, like so:</p> test_calculator.py<pre><code>def test_operations() -&gt; None:\n    assert add(2, 3) == 5\n    assert add(-1, 1) == 0\n\n    assert subtract(5, 2) == 3\n    assert subtract(0, 1) == -1\n\n    assert multiply(2, 3) == 6\n    assert multiply(0, 5) == 0\n\n    assert divide(6, 2) == 3\n    with pytest.raises(ValueError, match=\"divide by zero\"):\n        divide(6, 0)\n</code></pre> <p>But that test is testing way too many different things. If it breaks, all we know is that the calculator doesn\u2019t work any more, we don\u2019t know which parts still work and which part broke.</p> <p>Whereas if we split it into true unit tests, like so:</p> test_calculator.py<pre><code>def test_add() -&gt; None:\n    assert add(2, 3) == 5\n    assert add(-1, 1) == 0\n\n\ndef test_subtract() -&gt; None:\n    assert subtract(5, 2) == 3\n    assert subtract(0, 1) == -1\n\n\ndef test_multiply() -&gt; None:\n    assert multiply(2, 3) == 6\n    assert multiply(0, 5) == 0\n\n\ndef test_divide_valid() -&gt; None:\n    assert divide(6, 2) == 3\n    assert divide(-6, 2) == -3\n\n\ndef test_divide_by_zero() -&gt; None:\n    with pytest.raises(ValueError, match=\"divide by zero\"):\n        divide(6, 0)\n</code></pre> <p>If one test breaks, we instantly know which part of the calculator is broken. We even have a specific test for the edge case of the division operation.</p> <p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"}]}