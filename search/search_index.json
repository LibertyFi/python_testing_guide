{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the home page of the project.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Tutorial: A tutorial on how to write tests in Python</li> <li>Guide: The guidelines for writing Python tests at Libertify</li> </ul>"},{"location":"guide/","title":"Guide","text":"<ul> <li>Use MagicMock and AsyncMock, avoid using Mock unless there\u2019s a good reason not to auto mock the magic methods</li> <li>Use MagicMock with spec_set if only the class attributes need to be mocked MagicMock(spec_set=MyClass)</li> <li>Use MagicMock with spec if instance attributes need to be mocked. You can specify the instance attributes in a one liner MagicMock(spec=MyClass, attribute_0 = \u201cvalue0\u201d, attribute_1 = \u201cvalue1\u201d).</li> <li>Never use MagicMock without spec or spec_set</li> <li>Structure your test file like so:</li> <li>imports</li> <li>common mock constants</li> <li>test fixtures</li> <li>tests</li> <li>Use helper functions to avoid duplicating code between tests, for initialization code or mock setup for instance. Put the helper functions inbetween the tests, before the tests that use them.</li> <li>Use patch decorators to mock things for a specific test</li> <li>Use spec and spec_set in the patch if it patches a class or an object</li> <li>If the same patch or variable mock is used by more than 2 tests, make it a test fixture</li> <li>Structure your tests like so:</li> <li>initialization of variables and mocks</li> <li>empty line</li> <li>call to the function under test</li> <li>empty line</li> <li>mock calls asserts</li> <li>empty line</li> <li>value asserts</li> </ul>"},{"location":"tutorial/","title":"Welcome to the Python unit tests tutorial","text":""},{"location":"tutorial/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>pytest installed as a dev dependency</li> </ul>"},{"location":"tutorial/#what-unit-tests-are-for","title":"What Unit Tests Are For","text":"<ol> <li>Detecting Bugs Early: Unit tests catch errors and bugs in specific functions or methods before they become larger issues in the overall system.</li> <li>Ensuring Code Quality: They validate that the code behaves as intended, improving reliability.</li> <li>Facilitating Refactoring: With a suite of unit tests, you can confidently make changes to your codebase knowing that tests will alert you if something breaks.</li> <li>Documenting Behavior: Tests serve as documentation by illustrating how functions or methods are intended to work.</li> <li>Improving Development Speed: Though writing tests may seem like extra work, they save time in the long run by reducing debugging time and ensuring stability.</li> </ol>"},{"location":"tutorial/#how-to-write-unit-tests","title":"How to Write Unit Tests","text":""},{"location":"tutorial/#the-basics","title":"The Basics","text":""},{"location":"tutorial/#project-structure","title":"Project structure","text":"<p>The test files should be located in the <code>tests</code> directory. Then, for each source file/module, there should be a corresponding test file. The tests directory should have the same directory structure as the source code.</p> <p>For example, if we have the following project structure:</p> <pre><code>src/\n\u251c\u2500\u2500 level_0/\n\u2502 \u251c\u2500\u2500 calculator.py\n</code></pre> <p>The test files should be located in the <code>tests</code> directory.</p> <pre><code>tests/\n\u251c\u2500\u2500 level_0/\n\u2502 \u251c\u2500\u2500 test_calculator.py\n</code></pre>"},{"location":"tutorial/#how-big-should-each-unit-test-be","title":"How big should each unit test be?","text":"<p>The goal of unit testing is to verify that small, isolated units of code (usually functions or methods) perform correctly and handle edge cases as designed.</p> <p>As such a unit test should be as simple as possible and test only one thing.</p> <p>Take the following example of a calculator module:</p> calculator.py<pre><code>def add(a: float, b: float) -&gt; float:\n    return a + b\n\n\ndef subtract(a: float, b: float) -&gt; float:\n    return a - b\n\n\ndef multiply(a: float, b: float) -&gt; float:\n    return a * b\n\n\ndef divide(a: float, b: float) -&gt; float:\n    if b == 0:\n        msg = \"Cannot divide by zero\"\n        raise ValueError(msg)\n    return a / b\n</code></pre> <p>We could test that module with a single test, like so:</p> test_calculator.py<pre><code>def test_operations() -&gt; None:\n    assert add(2, 3) == 5\n    assert add(-1, 1) == 0\n\n    assert subtract(5, 2) == 3\n    assert subtract(0, 1) == -1\n\n    assert multiply(2, 3) == 6\n    assert multiply(0, 5) == 0\n\n    assert divide(6, 2) == 3\n    with pytest.raises(ValueError, match=\"divide by zero\"):\n        divide(6, 0)\n</code></pre> <p>But that test is testing way too many different things. If it breaks, all we know is that the calculator doesn\u2019t work any more, we don\u2019t know which parts still work and which part broke.</p> <p>Whereas if we split it into true unit tests, like so:</p> test_calculator.py<pre><code>def test_add() -&gt; None:\n    assert add(2, 3) == 5\n    assert add(-1, 1) == 0\n\n\ndef test_subtract() -&gt; None:\n    assert subtract(5, 2) == 3\n    assert subtract(0, 1) == -1\n\n\ndef test_multiply() -&gt; None:\n    assert multiply(2, 3) == 6\n    assert multiply(0, 5) == 0\n\n\ndef test_divide_valid() -&gt; None:\n    assert divide(6, 2) == 3\n    assert divide(-6, 2) == -3\n\n\ndef test_divide_by_zero() -&gt; None:\n    with pytest.raises(ValueError, match=\"divide by zero\"):\n        divide(6, 0)\n</code></pre> <p>If one test breaks, we instantly know which part of the calculator is broken. We even have a specific test for the edge case of the division operation.</p>"},{"location":"tutorial/#mocking","title":"Mocking","text":""},{"location":"tutorial/#what-is-mocking","title":"What is mocking?","text":"<p>Mocking is a technique used to replace a function or method with a mock implementation in order to test the code that uses it.</p> <p>Take the following example of a simple class:</p> session.py<pre><code>from src.level_1.interface import connect_to_server\n\n\nclass Session:\n    def connect(self) -&gt; bool:\n        return connect_to_server()\n</code></pre> <p>We could test the single method of the class like so:</p> test_session.py<pre><code>def test_connect() -&gt; None:\n    session = Session()\n\n    result = session.connect()\n\n    assert result\n</code></pre> <p>But the <code>connect_to_server</code> function comes from an external module, which we don't control in the <code>session</code> module. Each unit test should only test one unit of code. This test is actually testing both <code>session.connect</code> and <code>interface.connect_to_server</code>. If the test fails, there is no way to tell if it's because of the <code>connect</code> method or the <code>connect_to_server</code> function.</p>"},{"location":"tutorial/#mocking-a-function","title":"Mocking a function","text":"<p>To properly test the above <code>connect</code> method, we should mock the <code>connect_to_server</code> function. Here's how we can do it, using the <code>patch</code> function (here in decorator form):</p> test_session.py<pre><code>@patch(\"src.level_1.session.connect_to_server\")\ndef test_connect_success(mock_connect_to_server: MagicMock) -&gt; None:\n    session = Session()\n    mock_connect_to_server.return_value = True\n\n    connected = session.connect()\n\n    # Check that the mock was called by the connect method\n    mock_connect_to_server.assert_called_once()\n\n    # Check that the connect method returns the correct value\n    assert connected\n\n\n@patch(\"src.level_1.session.connect_to_server\")\ndef test_connect_failure(mock_connect_to_server: MagicMock) -&gt; None:\n    session = Session()\n    mock_connect_to_server.return_value = False\n\n    connected = session.connect()\n\n    mock_connect_to_server.assert_called_once()\n\n    assert not connected\n</code></pre> <p>Mocking the <code>connect_to_server</code> function has several benefits:</p> <ul> <li>we're only testing the <code>connect</code> method, regardless of the actual implementation of <code>connect_to_server</code></li> <li>we're able to have two test cases for the <code>connect</code> method, one for when the connection is successful and one for when it's not because we control the return value of the mock</li> <li>we're not executing the actual <code>connect_to_server</code> function, which could require a specific setup, make network requests, or even be an expensive operation</li> </ul> <p>Patch in the right place</p> <p>When using the patch function, it's important to patch the function where it's used, not where it's defined.</p> <p> <code>patch(\"src.level_1.session.connect_to_server\")</code></p> <p> <code>patch(\"src.level_1.interface.connect_to_server\")</code></p>"},{"location":"tutorial/#mocking-an-object","title":"Mocking an object","text":"<p>Let's use the following class as an example:</p> session.py<pre><code>from src.level_2.interface import ServerInterface\n\n\nclass Session:\n    interface: ServerInterface\n\n    def __init__(self, interface: ServerInterface) -&gt; None:\n        self.interface = interface\n\n    def connect(self) -&gt; bool:\n        return self.interface.connect_to_server()\n</code></pre> <p>In order to test the <code>connect</code> method, we first need to instantiate a <code>Session</code> object, which requires an <code>ServerInterface</code> object.</p> <p>Since we don't know what creating an actual <code>ServerInterface</code> object entails, and we don't want to test the <code>ServerInterface</code> class, we need to mock the <code>ServerInterface</code> object.</p>"},{"location":"tutorial/#simple-mock","title":"Simple Mock","text":"<p>The simplest way to mock an object is to use the <code>Mock</code> class, from the <code>unittest.mock</code> module.</p> test_session.py<pre><code>def test_connect_success() -&gt; None:\n    interface = Mock()\n    interface.connect_to_server.return_value = True\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>Here we create a <code>Mock</code> object and assign a return value to its <code>connect_to_server</code> attribute.</p> <p>Now when the test calls <code>session.connect()</code>, it will call the <code>connect_to_server</code> method of the <code>Mock</code> instead of an actual <code>ServerInterface</code> object.</p> <p>And since we control the mock, we can even check that the <code>connect_to_server</code> method is indeed called by the <code>connect</code> method.</p>"},{"location":"tutorial/#specifying-the-mocks-structure","title":"Specifying the Mock's Structure","text":"<p><code>Mock</code> generates attributes on the fly so that the mock can be used automatically without worrying about setting it up. The downside of this is that you can use attributes that don't even exist on the original object.</p> <p>Here's an example:</p> interface.py<pre><code>import logging\n\n\nclass ServerInterface:\n    class_attribute = \"This is a class attribute\"\n\n    def __init__(self) -&gt; None:\n        self.instance_attribute = \"This is an instance attribute\"\n\n    def connect_to_server(self) -&gt; bool:\n        logging.info(\"Called actual connect_to_server\")\n        return True\n</code></pre> test_session.py<pre><code>def test_connect_success_shouldnt_be_allowed() -&gt; None:\n    interface = Mock()\n    interface.connect_to_server.return_value = True\n    # This doesn't raise an error, but it shouldn't be possible\n    interface.not_an_actual_attribute = \"This shouldn't be possible\"\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>The <code>ServerInterface</code> object we want to mock doesn't have a <code>not_an_actual_attribute</code> attribute, so we shouldn't allow the mock to have it. Moreover, even if the <code>connect</code> method actually uses <code>not_an_actual_attribute</code>, this test will still pass even though the attribute doesn't actually exist, which will make <code>connect</code> crash at runtime.</p> <p>Thankfully, there are ways to specify the structure of the mock object.</p> <p>The best (strictest) way is to use the <code>spec_set</code> argument to specify to the <code>Mock</code> constructor the class of the object we want to mock:</p> test_session.py<pre><code>def test_connect_success_spec_set() -&gt; None:\n    interface = Mock(spec_set=ServerInterface)\n    interface.connect_to_server.return_value = True\n    # This raises an AttributeError\n    # interface.not_an_actual_attribute = \"This shouldn't be possible\"  # noqa: ERA001\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>This will raise an error if we try to access an attribute that doesn't exist in the <code>ServerInterface</code> class.</p> <p>Unfortunately, instance attributes are not part of the class specification, so they don't exist as far as <code>spec_set</code> is concerned.</p> test_session.py<pre><code>def test_connect_success_spec_set_instance_attribute() -&gt; None:\n    interface = Mock(spec_set=ServerInterface)\n    interface.connect_to_server.return_value = True\n    # This works as expected\n    interface.class_attribute = \"This is a class attribute\"\n    # This raises an AttributeError\n    # interface.instance_attribute = \"This attribute doesn't exist when the mock is created\"  # noqa: ERA001\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>If you need to mock an instance attribute (or any attribute that is defined at runtime), you can use <code>spec</code> instead of <code>spec_set</code>:</p> test_session.py<pre><code>def test_connect_success_simple_spec_for_instance_attribute() -&gt; None:\n    interface = Mock(spec=ServerInterface)\n    interface.connect_to_server.return_value = True\n    interface.class_attribute = \"This is a class attribute\"\n    # Now this works\n    interface.instance_attribute = \"This is an instance attribute\"\n    # But this will still raise an AttributeError\n    # logging.info(f\"{interface.unset_instance_attribute}\")  # noqa: ERA001\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p><code>spec</code> vs <code>spec_set</code></p> <p><code>spec</code> is not as strict as <code>spec_set</code>, it will simply ensure that an attribute can't be accessed if it has not been set, whether by the test or the specified class:</p> test_session.py<pre><code>def test_connect_success_simple_spec_is_lax() -&gt; None:\n    interface = Mock(spec=ServerInterface)\n    interface.connect_to_server.return_value = True\n    # This will not raise an error\n    interface.not_an_actual_attribute = \"This doesn't exist in the specified class\"\n    session = Session(interface)\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>One-liner syntax</p> <p>You can also define the mock and its attributes at the same time if you prefer the one-liner syntax.</p> test_session.py<pre><code>def test_connect_success_simple_spec_one_liner() -&gt; None:\n    interface = Mock(\n        spec=ServerInterface,\n        class_attribute=\"This is a class attribute\",\n        instance_attribute=\"This is an instance attribute\",\n        connect_to_server=Mock(return_value=True),\n    )\n</code></pre>"},{"location":"tutorial/#when-mock-is-not-enough","title":"When Mock is not enough","text":""},{"location":"tutorial/#magicmock","title":"MagicMock","text":"<p>Sometimes using <code>Mock</code> is not enough. Let's take this new example class:</p> session.py<pre><code>from src.level_3.interface import ServerInterface\n\n\nclass Session:\n    interface: ServerInterface\n    active_connections: int = 0\n\n    def __init__(self, interface: ServerInterface) -&gt; None:\n        self.interface = interface\n\n    def connect(self) -&gt; bool:\n        self.active_connections += 1\n        return self.interface.connect_to_server()\n\n    async def aconnect(self) -&gt; bool:\n        self.active_connections += 1\n        return await self.interface.aconnect_to_server()\n</code></pre> <p>We can try testing the <code>connect</code> method with <code>Mock</code> as we did before:</p> test_session.py<pre><code>def test_connect_success_missing_magic_method() -&gt; None:\n    interface = Mock()\n    session = Session(interface)\n    # This raises a TypeError because Mock doesn't implement the magic/special __add__ method so it can't effectively\n    # mock an int\n    # session.active_connections = Mock()  # noqa: ERA001\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>Unfortunately mocking the <code>active_connections</code> attribute with <code>Mock</code> doesn't work because <code>Mock</code> doesn't implement the magic/special <code>__add__</code> method so it can't effectively mock an <code>int</code>.</p> <p>We could mock the <code>__add__</code> method ourselves, but that would be tedious and error-prone since it's not always obvious which magic methods are used by the code.</p> <p>Fortunately, <code>Mock</code> has a subclass called <code>MagicMock</code> that automatically implements the magic/special methods:</p> test_session.py<pre><code>def test_connect_success_magic() -&gt; None:\n    interface = Mock()\n    session = Session(interface)\n    # This works as expected because MagicMock automatically implements the magic/special methods, including __add__\n    session.active_connections = MagicMock()\n\n    connected = session.connect()\n\n    interface.connect_to_server.assert_called_once()\n\n    assert connected\n</code></pre> <p>Using <code>MagicMock</code> we don't have to worry about mocking any magic/special methods ourselves.</p> <p>Magic Methods</p> <p>If you use the <code>spec</code> or <code>spec_set</code> arguments then only magic methods that exist in the spec will be created. You can override the magic methods of a <code>MagicMock</code> by setting them just like you would with a normal <code>Mock</code>.</p>"},{"location":"tutorial/#asyncmock","title":"AsyncMock","text":"<p>We'd also like to test the <code>aconnect</code> method, but it's an async function so we can't use a simple <code>Mock</code> to mock it.</p> <p>Fortunately, <code>Mock</code> has a subclass called <code>AsyncMock</code> that can be used to mock async functions:</p> test_session.py<pre><code>@pytest.mark.asyncio\nasync def test_aconnect_async_mock() -&gt; None:\n    interface = Mock()\n    # This raises a TypeError because the mock will simply return a boolean instead of a coroutine\n    # interface.aconnect_to_server.return_value = True  # noqa: ERA001\n    # We need to use AsyncMock to mock the async function properly\n    interface.aconnect_to_server = AsyncMock(return_value=True)\n    session = Session(interface)\n\n    connected = await session.aconnect()\n\n    # We could use assert_called_once() as well, but assert_awaited_once() is more specific\n    interface.aconnect_to_server.assert_awaited_once()\n\n    assert connected\n</code></pre> <p>AsyncMock calls</p> <p>You can use <code>assert_awaited_once()</code> or similar methods to check that an async function is awaited and not just called.</p> <p>Decorator for async tests</p> <p>The <code>@pytest.mark.asyncio</code> decorator is required to run async tests.</p>"},{"location":"tutorial/#mocking-a-class","title":"Mocking a class","text":""},{"location":"tutorial/#test-fixtures","title":"Test Fixtures","text":""},{"location":"tutorial/#advanced-mocking","title":"Advanced Mocking","text":""}]}